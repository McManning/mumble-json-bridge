// Copyright 2020 The Mumble Developers. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file at the root of the
// source tree.

// This file was auto-generated by scripts/generate_APICall_implementation.py. DO NOT EDIT MANUALLY!

const std::unordered_set< std::string > APICall::s_allFunctions = { "freeMemory",
																	"getActiveServerConnection",
																	"isConnectionSynchronized",
																	"getLocalUserID",
																	"getUserName",
																	"getChannelName",
																	"getAllUsers",
																	"getAllChannels",
																	"getChannelOfUser",
																	"getUsersInChannel",
																	"getLocalUserTransmissionMode",
																	"isUserLocallyMuted",
																	"isLocalUserMuted",
																	"isLocalUserDeafened",
																	"getUserHash",
																	"getServerHash",
																	"getUserComment",
																	"getChannelDescription",
																	"requestLocalUserTransmissionMode",
																	"requestUserMove",
																	"requestMicrophoneActivationOvewrite",
																	"requestLocalMute",
																	"requestLocalUserMute",
																	"requestLocalUserDeaf",
																	"requestSetLocalUserComment",
																	"findUserByName",
																	"findUserByName_noexcept",
																	"findChannelByName",
																	"findChannelByName_noexcept",
																	"getMumbleSetting_bool",
																	"getMumbleSetting_int",
																	"getMumbleSetting_double",
																	"getMumbleSetting_string",
																	"setMumbleSetting_bool",
																	"setMumbleSetting_int",
																	"setMumbleSetting_double",
																	"setMumbleSetting_string",
																	"sendData",
																	"log",
																	"log_noexcept",
																	"playSample" };

const std::unordered_set< std::string > APICall::s_noParamFunctions = { "getActiveServerConnection",
																		"getLocalUserTransmissionMode",
																		"isLocalUserMuted", "isLocalUserDeafened" };

nlohmann::json handle_freeMemory(const MumbleAPI &api, const std::string &bridgeSecret,
								 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"freeMemory\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "pointer", number_unsigned);

	// Convert the parameter from JSON to the corresponding cpp types
	void *pointer = reinterpret_cast< void * >(parameter["pointer"].get< uintptr_t >());

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.freeMemory(pointer);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "freeMemory"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getActiveServerConnection(const MumbleAPI &api, const std::string &bridgeSecret) {
	// Call respective API function
	nlohmann::json response;

	try {
		mumble_connection_t ret = api.getActiveServerConnection();

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getActiveServerConnection"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_isConnectionSynchronized(const MumbleAPI &api, const std::string &bridgeSecret,
											   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"isConnectionSynchronized\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		bool ret = api.isConnectionSynchronized(connection);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "isConnectionSynchronized"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getLocalUserID(const MumbleAPI &api, const std::string &bridgeSecret,
									 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"getLocalUserID\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		mumble_userid_t ret = api.getLocalUserID(connection);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getLocalUserID"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getUserName(const MumbleAPI &api, const std::string &bridgeSecret,
								  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"getUserName\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_id", number_unsigned);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_userid_t user_id        = parameter["user_id"].get< mumble_userid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleString ret = api.getUserName(connection, user_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getUserName"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getChannelName(const MumbleAPI &api, const std::string &bridgeSecret,
									 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"getChannelName\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "channel_id", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_channelid_t channel_id  = parameter["channel_id"].get< mumble_channelid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleString ret = api.getChannelName(connection, channel_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getChannelName"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getAllUsers(const MumbleAPI &api, const std::string &bridgeSecret,
								  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"getAllUsers\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleArray< mumble_userid_t > ret = api.getAllUsers(connection);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getAllUsers"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getAllChannels(const MumbleAPI &api, const std::string &bridgeSecret,
									 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"getAllChannels\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleArray< mumble_channelid_t > ret = api.getAllChannels(connection);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getAllChannels"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getChannelOfUser(const MumbleAPI &api, const std::string &bridgeSecret,
									   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"getChannelOfUser\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_id", number_unsigned);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_userid_t user_id        = parameter["user_id"].get< mumble_userid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		mumble_channelid_t ret = api.getChannelOfUser(connection, user_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getChannelOfUser"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getUsersInChannel(const MumbleAPI &api, const std::string &bridgeSecret,
										const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"getUsersInChannel\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "channel_id", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_channelid_t channel_id  = parameter["channel_id"].get< mumble_channelid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleArray< mumble_userid_t > ret = api.getUsersInChannel(connection, channel_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getUsersInChannel"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getLocalUserTransmissionMode(const MumbleAPI &api, const std::string &bridgeSecret) {
	// Call respective API function
	nlohmann::json response;

	try {
		mumble_transmission_mode_t ret = api.getLocalUserTransmissionMode();

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getLocalUserTransmissionMode"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_isUserLocallyMuted(const MumbleAPI &api, const std::string &bridgeSecret,
										 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"isUserLocallyMuted\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_id", number_unsigned);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_userid_t user_id        = parameter["user_id"].get< mumble_userid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		bool ret = api.isUserLocallyMuted(connection, user_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "isUserLocallyMuted"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_isLocalUserMuted(const MumbleAPI &api, const std::string &bridgeSecret) {
	// Call respective API function
	nlohmann::json response;

	try {
		bool ret = api.isLocalUserMuted();

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "isLocalUserMuted"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_isLocalUserDeafened(const MumbleAPI &api, const std::string &bridgeSecret) {
	// Call respective API function
	nlohmann::json response;

	try {
		bool ret = api.isLocalUserDeafened();

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "isLocalUserDeafened"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getUserHash(const MumbleAPI &api, const std::string &bridgeSecret,
								  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"getUserHash\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_id", number_unsigned);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_userid_t user_id        = parameter["user_id"].get< mumble_userid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleString ret = api.getUserHash(connection, user_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getUserHash"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getServerHash(const MumbleAPI &api, const std::string &bridgeSecret,
									const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"getServerHash\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleString ret = api.getServerHash(connection);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getServerHash"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getUserComment(const MumbleAPI &api, const std::string &bridgeSecret,
									 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"getUserComment\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_id", number_unsigned);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_userid_t user_id        = parameter["user_id"].get< mumble_userid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleString ret = api.getUserComment(connection, user_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getUserComment"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getChannelDescription(const MumbleAPI &api, const std::string &bridgeSecret,
											const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"getChannelDescription\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "channel_id", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_channelid_t channel_id  = parameter["channel_id"].get< mumble_channelid_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleString ret = api.getChannelDescription(connection, channel_id);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getChannelDescription"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_requestLocalUserTransmissionMode(const MumbleAPI &api, const std::string &bridgeSecret,
													   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"requestLocalUserTransmissionMode\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "transmission_mode", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_transmission_mode_t transmission_mode = parameter["transmission_mode"].get< mumble_transmission_mode_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.requestLocalUserTransmissionMode(transmission_mode);

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "requestLocalUserTransmissionMode"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_requestUserMove(const MumbleAPI &api, const std::string &bridgeSecret,
									  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 4) {
		throw InvalidMessageException(std::string("API function \"requestUserMove\" expects 4 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_id", number_unsigned);
	MESSAGE_ASSERT_FIELD(parameter, "channel_id", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "password", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_userid_t user_id        = parameter["user_id"].get< mumble_userid_t >();
	mumble_channelid_t channel_id  = parameter["channel_id"].get< mumble_channelid_t >();
	std::string password           = parameter["password"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.requestUserMove(connection, user_id, channel_id, password.c_str());

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "requestUserMove"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_requestMicrophoneActivationOvewrite(const MumbleAPI &api, const std::string &bridgeSecret,
														  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"requestMicrophoneActivationOvewrite\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "activate", boolean);

	// Convert the parameter from JSON to the corresponding cpp types
	bool activate = parameter["activate"].get< bool >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.requestMicrophoneActivationOvewrite(activate);

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "requestMicrophoneActivationOvewrite"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_requestLocalMute(const MumbleAPI &api, const std::string &bridgeSecret,
									   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 3) {
		throw InvalidMessageException(std::string("API function \"requestLocalMute\" expects 3 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_id", number_unsigned);
	MESSAGE_ASSERT_FIELD(parameter, "muted", boolean);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	mumble_userid_t user_id        = parameter["user_id"].get< mumble_userid_t >();
	bool muted                     = parameter["muted"].get< bool >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.requestLocalMute(connection, user_id, muted);

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "requestLocalMute"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_requestLocalUserMute(const MumbleAPI &api, const std::string &bridgeSecret,
										   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"requestLocalUserMute\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "muted", boolean);

	// Convert the parameter from JSON to the corresponding cpp types
	bool muted = parameter["muted"].get< bool >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.requestLocalUserMute(muted);

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "requestLocalUserMute"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_requestLocalUserDeaf(const MumbleAPI &api, const std::string &bridgeSecret,
										   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"requestLocalUserDeaf\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "deafened", boolean);

	// Convert the parameter from JSON to the corresponding cpp types
	bool deafened = parameter["deafened"].get< bool >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.requestLocalUserDeaf(deafened);

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "requestLocalUserDeaf"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_requestSetLocalUserComment(const MumbleAPI &api, const std::string &bridgeSecret,
												 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"requestSetLocalUserComment\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "comment", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	std::string comment            = parameter["comment"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.requestSetLocalUserComment(connection, comment.c_str());

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "requestSetLocalUserComment"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_findUserByName(const MumbleAPI &api, const std::string &bridgeSecret,
									 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"findUserByName\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_name", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	std::string user_name          = parameter["user_name"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		mumble_userid_t ret = api.findUserByName(connection, user_name.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "findUserByName"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_findUserByName_noexcept(const MumbleAPI &api, const std::string &bridgeSecret,
											  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"findUserByName_noexcept\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "user_name", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	std::string user_name          = parameter["user_name"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		std::optional< mumble_userid_t > ret = api.findUserByName_noexcept(connection, user_name.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "findUserByName_noexcept"},
					{"status", "executed"},
					{"return_value", ret.value()}
				}
			}
		};
		// clang-format on
	} catch (const std::bad_optional_access &) {
		// clang-format off
		response = {
			{"response_type", "api_error_optional"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_message", "Optional value not present"},
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_findChannelByName(const MumbleAPI &api, const std::string &bridgeSecret,
										const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(std::string("API function \"findChannelByName\" expects 2 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "channel_name", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	std::string channel_name       = parameter["channel_name"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		mumble_channelid_t ret = api.findChannelByName(connection, channel_name.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "findChannelByName"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_findChannelByName_noexcept(const MumbleAPI &api, const std::string &bridgeSecret,
												 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"findChannelByName_noexcept\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "channel_name", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection = parameter["connection"].get< mumble_connection_t >();
	std::string channel_name       = parameter["channel_name"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		std::optional< mumble_channelid_t > ret = api.findChannelByName_noexcept(connection, channel_name.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "findChannelByName_noexcept"},
					{"status", "executed"},
					{"return_value", ret.value()}
				}
			}
		};
		// clang-format on
	} catch (const std::bad_optional_access &) {
		// clang-format off
		response = {
			{"response_type", "api_error_optional"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_message", "Optional value not present"},
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getMumbleSetting_bool(const MumbleAPI &api, const std::string &bridgeSecret,
											const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"getMumbleSetting_bool\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		bool ret = api.getMumbleSetting_bool(key);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getMumbleSetting_bool"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getMumbleSetting_int(const MumbleAPI &api, const std::string &bridgeSecret,
										   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"getMumbleSetting_int\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		int ret = api.getMumbleSetting_int(key);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getMumbleSetting_int"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getMumbleSetting_double(const MumbleAPI &api, const std::string &bridgeSecret,
											  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"getMumbleSetting_double\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		double ret = api.getMumbleSetting_double(key);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getMumbleSetting_double"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_getMumbleSetting_string(const MumbleAPI &api, const std::string &bridgeSecret,
											  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(
			std::string("API function \"getMumbleSetting_string\" expects 1 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		MumbleString ret = api.getMumbleSetting_string(key);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "getMumbleSetting_string"},
					{"status", "executed"},
					{"return_value", ret}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_setMumbleSetting_bool(const MumbleAPI &api, const std::string &bridgeSecret,
											const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"setMumbleSetting_bool\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);
	MESSAGE_ASSERT_FIELD(parameter, "value", boolean);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();
	bool value                = parameter["value"].get< bool >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.setMumbleSetting_bool(key, value);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "setMumbleSetting_bool"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_setMumbleSetting_int(const MumbleAPI &api, const std::string &bridgeSecret,
										   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"setMumbleSetting_int\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);
	MESSAGE_ASSERT_FIELD(parameter, "value", number_integer);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();
	int value                 = parameter["value"].get< int >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.setMumbleSetting_int(key, value);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "setMumbleSetting_int"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_setMumbleSetting_double(const MumbleAPI &api, const std::string &bridgeSecret,
											  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"setMumbleSetting_double\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);
	MESSAGE_ASSERT_FIELD(parameter, "value", number_float);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();
	double value              = parameter["value"].get< double >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.setMumbleSetting_double(key, value);

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "setMumbleSetting_double"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_setMumbleSetting_string(const MumbleAPI &api, const std::string &bridgeSecret,
											  const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 2) {
		throw InvalidMessageException(
			std::string("API function \"setMumbleSetting_string\" expects 2 parameter(s) but got ")
			+ std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "key", string);
	MESSAGE_ASSERT_FIELD(parameter, "value", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_settings_key_t key = parameter["key"].get< mumble_settings_key_t >();
	std::string value         = parameter["value"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.setMumbleSetting_string(key, value.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "setMumbleSetting_string"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_sendData(const MumbleAPI &api, const std::string &bridgeSecret, const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 4) {
		throw InvalidMessageException(std::string("API function \"sendData\" expects 4 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "connection", number_integer);
	MESSAGE_ASSERT_FIELD(parameter, "receivers", array);
	MESSAGE_ASSERT_FIELD(parameter, "data", array);
	MESSAGE_ASSERT_FIELD(parameter, "data_id", string);

	// Convert the parameter from JSON to the corresponding cpp types
	mumble_connection_t connection           = parameter["connection"].get< mumble_connection_t >();
	std::vector< mumble_userid_t > receivers = parameter["receivers"].get< std::vector< mumble_userid_t > >();
	std::vector< uint8_t > data              = parameter["data"].get< std::vector< uint8_t > >();
	std::string data_id                      = parameter["data_id"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.sendData(connection, receivers, data, data_id.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "sendData"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_log(const MumbleAPI &api, const std::string &bridgeSecret, const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"log\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "message", string);

	// Convert the parameter from JSON to the corresponding cpp types
	std::string message = parameter["message"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.log(message.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "log"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json handle_log_noexcept(const MumbleAPI &api, const std::string &bridgeSecret,
								   const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"log_noexcept\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "message", string);

	// Convert the parameter from JSON to the corresponding cpp types
	std::string message = parameter["message"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	mumble_error_t ret = api.log_noexcept(message.c_str());

	// clang-format off
	response = {
		{"response_type", "api_call"},
		{"secret", bridgeSecret},
		{"response",
			{
				{"function", "log_noexcept"},
				{"status", "executed"},
				{"return_value", ret}
			}
		}
	};
	// clang-format on

	return response;
}

nlohmann::json handle_playSample(const MumbleAPI &api, const std::string &bridgeSecret,
								 const nlohmann::json &parameter) {
	// Validate specified parameter
	if (parameter.size() != 1) {
		throw InvalidMessageException(std::string("API function \"playSample\" expects 1 parameter(s) but got ")
									  + std::to_string(parameter.size()));
	}
	MESSAGE_ASSERT_FIELD(parameter, "sample_path", string);

	// Convert the parameter from JSON to the corresponding cpp types
	std::string sample_path = parameter["sample_path"].get< std::string >();

	// Call respective API function with extracted parameter
	nlohmann::json response;

	try {
		api.playSample(sample_path.c_str());

		// clang-format off
		response = {
			{"response_type", "api_call"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"function", "playSample"},
					{"status", "executed"}
				}
			}
		};
		// clang-format on
	} catch (const MumbleAPIException &e) {
		// clang-format off
		response = {
			{"response_type", "api_error"},
			{"secret", bridgeSecret},
			{"response",
				{
					{"error_code", e.errorCode()},
					{"error_message", e.what()}
				}
			}
		};
		// clang-format on
	}

	return response;
}

nlohmann::json execute(const std::string &functionName, const MumbleAPI &api, const std::string &bridgeSecret,
					   const nlohmann::json &msg) {
	if (functionName == "freeMemory") {
		return handle_freeMemory(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getActiveServerConnection") {
		return handle_getActiveServerConnection(api, bridgeSecret);
	} else if (functionName == "isConnectionSynchronized") {
		return handle_isConnectionSynchronized(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getLocalUserID") {
		return handle_getLocalUserID(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getUserName") {
		return handle_getUserName(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getChannelName") {
		return handle_getChannelName(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getAllUsers") {
		return handle_getAllUsers(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getAllChannels") {
		return handle_getAllChannels(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getChannelOfUser") {
		return handle_getChannelOfUser(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getUsersInChannel") {
		return handle_getUsersInChannel(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getLocalUserTransmissionMode") {
		return handle_getLocalUserTransmissionMode(api, bridgeSecret);
	} else if (functionName == "isUserLocallyMuted") {
		return handle_isUserLocallyMuted(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "isLocalUserMuted") {
		return handle_isLocalUserMuted(api, bridgeSecret);
	} else if (functionName == "isLocalUserDeafened") {
		return handle_isLocalUserDeafened(api, bridgeSecret);
	} else if (functionName == "getUserHash") {
		return handle_getUserHash(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getServerHash") {
		return handle_getServerHash(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getUserComment") {
		return handle_getUserComment(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getChannelDescription") {
		return handle_getChannelDescription(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "requestLocalUserTransmissionMode") {
		return handle_requestLocalUserTransmissionMode(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "requestUserMove") {
		return handle_requestUserMove(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "requestMicrophoneActivationOvewrite") {
		return handle_requestMicrophoneActivationOvewrite(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "requestLocalMute") {
		return handle_requestLocalMute(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "requestLocalUserMute") {
		return handle_requestLocalUserMute(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "requestLocalUserDeaf") {
		return handle_requestLocalUserDeaf(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "requestSetLocalUserComment") {
		return handle_requestSetLocalUserComment(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "findUserByName") {
		return handle_findUserByName(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "findUserByName_noexcept") {
		return handle_findUserByName_noexcept(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "findChannelByName") {
		return handle_findChannelByName(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "findChannelByName_noexcept") {
		return handle_findChannelByName_noexcept(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getMumbleSetting_bool") {
		return handle_getMumbleSetting_bool(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getMumbleSetting_int") {
		return handle_getMumbleSetting_int(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getMumbleSetting_double") {
		return handle_getMumbleSetting_double(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "getMumbleSetting_string") {
		return handle_getMumbleSetting_string(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "setMumbleSetting_bool") {
		return handle_setMumbleSetting_bool(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "setMumbleSetting_int") {
		return handle_setMumbleSetting_int(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "setMumbleSetting_double") {
		return handle_setMumbleSetting_double(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "setMumbleSetting_string") {
		return handle_setMumbleSetting_string(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "sendData") {
		return handle_sendData(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "log") {
		return handle_log(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "log_noexcept") {
		return handle_log_noexcept(api, bridgeSecret, msg["parameter"]);
	} else if (functionName == "playSample") {
		return handle_playSample(api, bridgeSecret, msg["parameter"]);
	}

	throw std::invalid_argument(std::string("Unknown API function \"") + functionName + "\"");
}

