// Copyright 2020 The Mumble Developers. All rights reserved.
// Use of this source code is governed by a BSD-style license
// that can be found in the LICENSE file at the root of the
// source tree.

// This file was auto-generated by scripts/generate_CLI_operations.py. DO NOT EDIT MANUALLY!

#include "handleOperation.h"

#include <mumble/json_bridge/messages/Message.h>

void checkAPIResponse(const nlohmann::json &response) {
	if (response.contains("response_type") && response["response_type"].get< std::string >() == "api_call") {
		// All good
		return;
	}

	// There seems to have been an error
	if (!response.contains("response_type") || !response.contains("response")) {
		// We can't process this response - seems invalid
		throw OperationException("Got invalid response from Mumble-JSON-Bridge.");
	}

	if (response["response_type"].get< std::string >() == "api_error"
		|| response["response_type"].get< std::string >() == "api_error_optional"
		|| response["response_type"].get< std::string >() == "error") {
		throw OperationException(response["response"]["error_message"].get< std::string >());
	} else {
		throw OperationException("Generic API error ecountered");
	}
}

nlohmann::json
	handle_get_local_user_name_operation(const nlohmann::json &msg,
										 const std::function< nlohmann::json(nlohmann::json &) > &executeQuery) {
	if (msg.contains("parameter")) {
		::Mumble::JsonBridge::Messages::InvalidMessageException(
			"Operation \"get_local_user_name\" does not take any parameter");
	}

	// Obtain all needed values

	// clang-format off
	nlohmann::json query1 = {
		{ "message_type", "api_call" },
		{ "message",
			{
				{ "function", "getActiveServerConnection" }
			}
		}
	};
	// clang-format on

	nlohmann::json response1 = executeQuery(query1);

	checkAPIResponse(response1);
	int connectionID = response1["response"]["return_value"].get< int >();

	// clang-format off
	nlohmann::json query2 = {
		{ "message_type", "api_call" },
		{ "message",
			{
				{ "function", "getLocalUserID" },
				{ "parameter",
					{
						{ "connection", connectionID }
					}
				}
			}
		}
	};
	// clang-format on

	nlohmann::json response2 = executeQuery(query2);

	checkAPIResponse(response2);
	int userID = response2["response"]["return_value"].get< int >();


	// Now actually execute the operation
	// clang-format off
	nlohmann::json operationQuery = {
		{ "message_type", "api_call" },
		{ "message",
			{
				{ "function", "getUserName" },
				{ "parameter",
					{
						{ "connection", connectionID },
						{ "user_id", userID }
					}
				}
			}
		}
	};
	// clang-format on

	nlohmann::json result = executeQuery(operationQuery);

	return result;
}

nlohmann::json handle_move_operation(const nlohmann::json &msg,
									 const std::function< nlohmann::json(nlohmann::json &) > &executeQuery) {
	// Validate and extract parameter

	MESSAGE_ASSERT_FIELD(msg, "parameter", object);

	const nlohmann::json &operationParams = msg["parameter"];

	if (operationParams.size() != 2) {
		throw ::Mumble::JsonBridge::Messages::InvalidMessageException(
			std::string("Operation \"move\" expects 2 parameter, but was provided with ")
			+ std::to_string(operationParams.size()));
	}

	MESSAGE_ASSERT_FIELD(operationParams, "user", string);
	std::string user = operationParams["user"].get< std::string >();

	MESSAGE_ASSERT_FIELD(operationParams, "channel", string);
	std::string channel = operationParams["channel"].get< std::string >();

	// Obtain all needed values

	// clang-format off
	nlohmann::json query1 = {
		{ "message_type", "api_call" },
		{ "message",
			{
				{ "function", "getActiveServerConnection" }
			}
		}
	};
	// clang-format on

	nlohmann::json response1 = executeQuery(query1);

	checkAPIResponse(response1);
	int connectionID = response1["response"]["return_value"].get< int >();

	// clang-format off
	nlohmann::json query2 = {
		{ "message_type", "api_call" },
		{ "message",
			{
				{ "function", "findUserByName" },
				{ "parameter",
					{
						{ "connection", connectionID },
						{ "user_name", user }
					}
				}
			}
		}
	};
	// clang-format on

	nlohmann::json response2 = executeQuery(query2);

	checkAPIResponse(response2);
	int userID = response2["response"]["return_value"].get< int >();

	// clang-format off
	nlohmann::json query3 = {
		{ "message_type", "api_call" },
		{ "message",
			{
				{ "function", "findChannelByName" },
				{ "parameter",
					{
						{ "connection", connectionID },
						{ "channel_name", channel }
					}
				}
			}
		}
	};
	// clang-format on

	nlohmann::json response3 = executeQuery(query3);

	checkAPIResponse(response3);
	int channelID = response3["response"]["return_value"].get< int >();


	// Now actually execute the operation
	// clang-format off
	nlohmann::json operationQuery = {
		{ "message_type", "api_call" },
		{ "message",
			{
				{ "function", "requestUserMove" },
				{ "parameter",
					{
						{ "connection", connectionID },
						{ "user_id", userID },
						{ "channel_id", channelID },
						{ "password", "" }
					}
				}
			}
		}
	};
	// clang-format on

	nlohmann::json result = executeQuery(operationQuery);

	return result;
}

nlohmann::json handleOperation(const nlohmann::json &msg,
							   const std::function< nlohmann::json(nlohmann::json &) > &executeQuery) {
	if (!msg.contains("operation") || !msg["operation"].is_string()) {
		throw OperationException("Missing \"operation\" field (required to be of type string)");
	}

	if (msg["operation"].get< std::string >() == "get_local_user_name") {
		return handle_get_local_user_name_operation(msg, executeQuery);
	} else if (msg["operation"].get< std::string >() == "move") {
		return handle_move_operation(msg, executeQuery);
	} else {
		throw OperationException(std::string("Unknown operation \"") + msg["operation"].get< std::string >() + "\"");
	}
}
