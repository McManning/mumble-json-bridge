#!/usr/bin/env python3
#
# Copyright 2020 The Mumble Developers. All rights reserved.
# Use of this source code is governed by a BSD-style license
# that can be found in the LICENSE file at the root of the
# Mumble source tree or at <https://www.mumble.info/LICENSE>.

import re
import argparse
from datetime import datetime

class Parameter:
    def __init__(self, name, paramType):
        self.m_name = name
        self.m_type = paramType

def camel_to_snake(name):
    converted = ""
    prevConverted = False
    for c in name:
        if c.isupper():
            if prevConverted:
                converted += c.lower()
            else:
                prevConverted = True
                converted += "_" + c.lower()
        else:
            prevConverted = False
            converted += c

    return converted.lstrip("_")

def getJsonType(cppType):
    if cppType == "const char *" or cppType == "std::string" or cppType == "MumbleString":
        return "string"
    elif cppType == "int":
        return "number_integer"
    elif cppType == "unsigned int" or cppType == "uint8_t" or cppType == "uint16_t" or cppType == "uint32_t":
        return "number_unsigned"
    elif cppType == "double" or cppType == "float":
        return "number_float"
    elif cppType == "mumble_error_t":
        return "number_unsigned"
    elif cppType == "bool":
        return "boolean"
    elif cppType == "mumble_connection_t":
        return "number_integer"
    elif cppType == "mumble_userid_t":
        return "number_unsigned"
    elif cppType == "mumble_channelid_t":
        return "number_integer"
    elif cppType == "mumble_transmission_mode_t":
        return "string"
    elif cppType == "mumble_settings_key_t":
        return "string"
    elif "std::vector" in cppType:
        return "array"
    elif cppType.endswith("*"):
        return "number_unsigned"

    raise RuntimeError("Unable to convert cpp-type " + cppType)

def generateLicenseHeader():
    currentYear = datetime.today().strftime("%Y")

    licenseHeader = "// Copyright " + (currentYear + "-" if not currentYear == "2020" else "") +  "2020 The Mumble Developers. All rights reserved.\n"
    licenseHeader += "// Use of this source code is governed by a BSD-style license\n"
    licenseHeader += "// that can be found in the LICENSE file at the root of the\n"
    licenseHeader += "// source tree.\n"

    return licenseHeader

def generateSetInit(name, elements):
    init = "const std::unordered_set<std::string> APICall::" + name + " = {\n"
    for current in elements:
        init += "\t\"" + current + "\",\n"

    # remove last ",\n"
    init = init[0 : -2]
    init += "\n};"

    return init

def generateExecuteFunction(functionNames, functionsWithoutParameters):
    func = "nlohmann::json execute(const std::string &functionName, const MumbleAPI &api, const std::string &bridgeSecret, "\
            + "const nlohmann::json &msg) {\n"
    
    for i in range(len(functionNames)):
        if i == 0:
            func += "\tif ("
        else:
            func += " else if ("

        func += "functionName == \"" + functionNames[i] + "\") {\n"
        func += "\t\treturn handle_" + functionNames[i] + "(api, bridgeSecret"
        if not functionNames[i] in functionsWithoutParameters:
            func += ", msg[\"parameter\"]"
        func += ");\n"
        func += "\t}"

    func += "\n\n"
    func += "\tthrow std::invalid_argument(std::string(\"Unknown API function \\\"\") + functionName + \"\\\"\");\n"
    func += "}"

    return func

def main():
    parser = argparse.ArgumentParser(description="Generates the implementation for the handle_* functions of the APICall class")
    parser.add_argument("-i", "--api-header", help="The path to the C++ API-wrapper header-file")
    parser.add_argument("-o", "--output-file", help="Path to which the generated source code shall be written")

    args = parser.parse_args()

    # read header and trim to relevant content
    apiHeader = open(args.api_header, "r").read()
    apiHeader = apiHeader[apiHeader.find("~MumbleAPI();") + 13 : apiHeader.rfind("};")]

    generatedImpl = generateLicenseHeader()

    generatedImpl += "\n"

    generatedImpl += "// This file was auto-generated by scripts/generate_APICall_implementation.py. DO NOT EDIT MANUALLY!\n"

    generatedImpl += "\n"

    # Add place-holder for init of static member variables containing function names
    generatedImpl += "%s\n\n"


    functionNames = []
    noParamFunctionNames = []

    functionPattern = re.compile("((?:\w|:|\<[^>]*\>)+)\s*(\w+)\s*\(([^)]*)\)\s*(.*)")
    functions = apiHeader.split(";")
    for currentFunction in functions:
        currentFunction = currentFunction.strip().replace("\n", " ").replace("\t", " ")
        # Trim multiple consecutive spaces
        currentFunction = re.sub(" +", " ", currentFunction)

        if not currentFunction:
            continue

        match = functionPattern.match(currentFunction)
        if not match:
            raise RuntimeError("Function RegEx doesn't work")

        returnType = match.group(1)
        functionName = match.group(2)
        parameterList = match.group(3).split(",")
        modifiers = match.group(4)

        parameter = []

        for currentParam in parameterList:
            currentParam = currentParam.strip()

            if not currentParam:
                continue

            # Strip defaul arguments
            if "=" in currentParam:
                currentParam = currentParam[0 : currentParam.find("=")].strip()

            match = re.match(".*?(\w+)$", currentParam)
            if not match:
                raise RuntimeError("Parameter RegEx not working")

            paramName = match.group(1)
            paramType = currentParam[0 : -len(paramName)].strip()

            # convert param name to snake_case in order to fit in the JSON naming scheme
            paramName = camel_to_snake(paramName)

            parameter.append(Parameter(paramName, paramType))

        functionNames.append(functionName)
        if len(parameter) == 0:
            noParamFunctionNames.append(functionName);
        
        generatedFunction = "nlohmann::json handle_" + functionName + "(const MumbleAPI &api, const std::string &bridgeSecret"

        if len(parameter) > 0:
            generatedFunction += ", const nlohmann::json &parameter"

        generatedFunction += ") {\n"

        # Generate verification code
        if len(parameter) > 0:
            generatedFunction += "\t// Validate specified parameter\n"
            generatedFunction += "\tif (parameter.size() != " + str(len(parameter)) + ") {\n"
            generatedFunction += "\t\tthrow InvalidMessageException(std::string(\"API function \\\"" + functionName + "\\\" expects " \
                    + str(len(parameter)) + " parameter(s) but got \") + std::to_string(parameter.size()));\n"
            generatedFunction += "\t}\n"

        for currentParam in parameter:
            generatedFunction += "\tMESSAGE_ASSERT_FIELD(parameter, \"" + currentParam.m_name + "\", " + getJsonType(currentParam.m_type) + ");\n"

        generatedFunction += "\n"
        if len(parameter) > 0:
            generatedFunction += "\t// Convert the parameter from JSON to the corresponding cpp types\n"

        # convert JSON to cpp
        for currentParam in parameter:
            paramType = currentParam.m_type
            # Use std::string for const char * types
            if paramType == "const char *":
                paramType = "std::string"
            # Remove const
            if paramType.startswith("const"):
                paramType = paramType[len("const"): ].strip()
            # Remove reference
            if paramType.endswith("&"):
                paramType = paramType[ : -1].strip()

            if not "*" in paramType:
                # Non-pointers
                generatedFunction += "\t" + paramType + " " +  currentParam.m_name + " = parameter[\"" + currentParam.m_name + "\"].get<"\
                        + paramType + ">();\n"
            else:
                # pointers
                generatedFunction += "\t" + paramType + " " +  currentParam.m_name + " = reinterpret_cast<" + paramType + \
                        ">(parameter[\"" + currentParam.m_name + "\"].get<" + "uintptr_t" + ">());\n"

        generatedFunction += "\n"
        generatedFunction += "\t// Call respective API function"
        if len(parameter) > 0:
            generatedFunction += " with extracted parameter"
        generatedFunction += "\n"

        # call API with extracted parameter
        generatedFunction += "\tnlohmann::json response;\n"

        generatedFunction += "\n"

        indent = "\t"
        if not "noexcept" in modifiers or "std::optional" in returnType:
            generatedFunction += "\ttry {\n"
            indent = "\t\t"

        generatedFunction += indent
        if not returnType == "void":
            generatedFunction += returnType + " ret = "

        generatedFunction += "api." + functionName + "("

        for currentParam in parameter:
            generatedFunction += currentParam.m_name
            if currentParam.m_type == "const char *":
                generatedFunction += ".c_str()"

            generatedFunction += ", "

        if len(parameter) > 0:
            # remove extra ", " at the end
            generatedFunction = generatedFunction[ : -2]

        generatedFunction += ");\n"

        generatedFunction += "\n"

        # report result
        generatedFunction += indent + "// clang-format off\n"
        generatedFunction += indent + "response = {\n"
        generatedFunction += indent + "\t{\"response_type\", \"api_call\"},\n"
        generatedFunction += indent + "\t{\"secret\", bridgeSecret},\n"
        generatedFunction += indent + "\t{\"response\",\n"
        generatedFunction += indent + "\t\t{\n"
        generatedFunction += indent + "\t\t\t{\"function\", \"" + functionName + "\"},\n"
        generatedFunction += indent + "\t\t\t{\"status\", \"executed\"}"
        if not returnType == "void":
            if not "std::optional" in returnType:
                generatedFunction += ",\n" + indent + "\t\t\t{\"return_value\", ret}"
            else:
                generatedFunction += ",\n" + indent + "\t\t\t{\"return_value\", ret.value()}"
        generatedFunction += "\n" + indent + "\t\t}\n"
        generatedFunction += indent + "\t}\n"
        generatedFunction += indent + "};\n"
        generatedFunction += indent + "// clang-format on\n"


        if not "noexcept" in modifiers or "std::optional" in returnType:
            generatedFunction += "\t}"

            if not "noexcept" in modifiers:
                generatedFunction += " catch (const MumbleAPIException &e) {\n"
                generatedFunction += "\t\t// clang-format off\n"
                generatedFunction += "\t\tresponse = {\n"
                generatedFunction += "\t\t\t{\"response_type\", \"api_error\"},\n"
                generatedFunction += "\t\t\t{\"secret\", bridgeSecret},\n"
                generatedFunction += "\t\t\t{\"response\",\n"
                generatedFunction += "\t\t\t\t{\n"
                generatedFunction += "\t\t\t\t\t{\"error_code\", e.errorCode()},\n"
                generatedFunction += "\t\t\t\t\t{\"error_message\", e.what()}\n"
                generatedFunction += "\t\t\t\t}\n"
                generatedFunction += "\t\t\t}\n"
                generatedFunction += "\t\t};\n"
                generatedFunction += "\t\t// clang-format on\n"
                generatedFunction += "\t}"

            if "std::optional" in returnType:
                generatedFunction += " catch (const std::bad_optional_access &e) {\n"
                generatedFunction += "\t\t// clang-format off\n"
                generatedFunction += "\t\tresponse = {\n"
                generatedFunction += "\t\t\t{\"response_type\", \"api_error_optional\"},\n"
                generatedFunction += "\t\t\t{\"secret\", bridgeSecret},\n"
                generatedFunction += "\t\t\t{\"response\",\n"
                generatedFunction += "\t\t\t\t{\n"
                generatedFunction += "\t\t\t\t\t{\"error_message\", \"Optional value not present\"},\n"
                generatedFunction += "\t\t\t\t}\n"
                generatedFunction += "\t\t\t}\n"
                generatedFunction += "\t\t};\n"
                generatedFunction += "\t\t// clang-format on\n"
                generatedFunction += "\t}"

            generatedFunction += "\n"

        generatedFunction += "\n"

        generatedFunction += "\treturn response;\n"

        generatedFunction += "}"

        generatedImpl += generatedFunction
        generatedImpl += "\n\n"

    

    initCode = generateSetInit("s_allFunctions", functionNames) + "\n\n"
    initCode += generateSetInit("s_noParamFunctions", noParamFunctionNames)

    generatedImpl = generatedImpl % initCode

    generatedImpl += generateExecuteFunction(functionNames, noParamFunctionNames) + "\n\n"

    if args.output_file is None:
        # print to standard output
        print(generatedImpl)
    else:
        outFile = open(args.output_file, "w")
        outFile.write(generatedImpl)




if __name__ == "__main__":
    main()
